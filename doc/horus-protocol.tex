\documentclass[11pt]{article}

\usepackage{times,fullpage}
\usepackage{xspace}

\newcommand{\mds}{\ensuremath{\mathit{MDS}}}
\newcommand{\kds}{\ensuremath{\mathit{KDS}}}
\newcommand{\osd}{\ensuremath{\mathit{OSD}}}

\begin{document}

This protocol is between metadata server ($\mds$), client ($C$), and
key distribution server ($\kds$) for a file with root key $K_R$ and
user $A$.  We assume that $\kds$ is given private key
$\textit{KR}_A$, which is paired with public key $\textit{KU}_A$.

\vspace{1ex}

The file in question is owned by the application $A$, and we want
to allow the full access permission to the file only to the
user $A$ and the trusted $\kds$.
In other words, both $C$ and $\mds$ are not
allowed to access the entire file, since both $C$ (i.e., a computation
node in a supercomputer system) and $\mds$ may be managed by a
company that is different from the entity that is trying to run
the application $A$ on the supercomputer.
Hence, the $\mds$ should not have the file's master key $K_R$.

The block size $bs$, the depth of the key hash tree $d$,
and the accessible block number $(i,j)$ for a client $C$,
which collectively determin the allowable range for $C$,
are decided by either $\kds$ or $A$.
The range parameters $(bs,d,i,j,C)$ for the file are
either stored in $\mds$ or in $\kds$.

$\mds$ is trusted in a level that $\mds$ is tamper-proof;
if $\kds$ or $A$ store the range parameters $(bs,d,i,j,C)$,
they must provide the correct value to the correct entity.
If $\mds$ is compromised, it could alter the owner of the file,
meaning that there is no point in worring about range alteration
in $\mds$.

We assume That ID theft or spoofing is securely prohitited by the system.
$C$ cannot impersonate $\mds$ or $\kds$ in the system.

To counteract against an alteration of allowable range by $C$ or
a replay attack after range update in the system,
$\kds$ must not be provided the range parameters by $C$.
This means that $\kds$ must either 1) have a database storing allowable
ranges for each clients $C$ and for each files, or
2) directly talk with $\mds$ to retrieve the range parameter for the file.
This document assumes 2) for ease of implementation.

$\mds$ provides the attributes of the file; i.e., the owner, permissions
(modes), the key-hash parameter for the file $(bs,d)$,
permitted range $(i,j)$ for a client $C$.
The file attributes are generally open to public, meaning that $\mds$
does not authenticate clients nor need to have clients' IDs.
$\mds$ does not need to distinguish $\kds$ from $C$.
$\mds$ may provide storage service for the keys managed by $\kds$;
$\mds$ may hold in an extended attribute the master key $K_R$
encrypted by $\kds$'s public key $KU_{\kds}$ or $A$'s public key $KU_{A}$.
In this way $\mds$ cannot have $K_R$ and hence cannot have
the full access to the file.
$\mds$ can be implemented as the meta data server in Ceph
or extended attributes (or "\textit{forks}") in other file systems.

\begin{eqnarray*}
   \mds & : & \mbox{a meta data server.} \\
   C    & : & \mbox{a client or a computation node.} \\
   \kds & : & \mbox{a key distribution server.} \\
   A    & : & \mbox{a user or an application.} \\
   \textit{KR}_A & : & \mbox{the private key for $A$.} \\
   \textit{KU}_A & : & \mbox{the public key for $A$.} \\
   (bs,d,i,j) & : & \mbox{block size $bs$, depth $d$, range $i,j$.} \\
\end{eqnarray*}

\clearpage

Resulting key exchange protocol in Horus is as follows.

User $A$ registers file attributes in extended attributes
in filesystem or in $\mds$. $A$ also registers $KR_A$ in $\kds$.

\begin{eqnarray}
A \rightarrow \mds & : & \{ path, bs, d, E_{KU_A}(K_R) \} \\
A \rightarrow \mds & : & \{ path, C_1, i_1, j_1 \} \\
A \rightarrow \mds & : & \{ path, C_2, i_2, j_2 \} \\
A \rightarrow \kds & : & KR_A
\end{eqnarray}

Computing node $C_2$ accesses the file data through the intervention
by $\kds$.

\begin{eqnarray}
C_2 \rightarrow \kds & : & \mbox{open request: } \{ path \} \\
\kds \rightarrow \mds & : & \mbox{attr request: } \{ path,C_2 \} \\
\mds \rightarrow \kds & : & \mbox{attr response: } \{ path,bs,d,E_{KU_A}(K_R),C_2,i_2,j_2 \} \\
\kds         & : & K_{i_2,j_2} \leftarrow E_{KU_A}(K_R) \times KR_A \\
\kds \rightarrow C_2 & : & \{ path, bs, d, i_2, j_2, K_{i_2,j_2} \} \\
C_2 \rightarrow \osd & : & \mbox{data request} \\
\osd \rightarrow C_2 & : & \mbox{data, then decrypted by } K_{i_2,j_2}
\end{eqnarray}

\end{document}

